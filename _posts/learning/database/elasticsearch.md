
---

# Elasticsearch 指南

## 1. 什么是 Elasticsearch？
Elasticsearch 是一个基于 Lucene 的搜索服务器，提供分布式、可扩展的实时搜索功能。

ElasticSearch对数据进行搜索、分析和存储，其是基于JSON的分布式搜索和分析引擎，专门为实现水平可扩展性、高可靠性和管理便捷性而设计的。

它的实现原理主要分为以下几个步骤：

1）首先用户将数据提交到ElasticSearch数据库中；

2）再通过分词控制器将对应的语句分词；

3）将分词结果及其权重一并存入，以备用户在搜索数据时，根据权重将结果排名和打分，将返回结果呈现给用户；

4）用户根据打分结果，对结果进行筛选，如：时间范围、地点等。



## 2. ES有哪些优化方法？
### 2.1 硬件优化
- CPU：尽量选择2-8核的机器
ES对于CPU上面的要求并不是那么高，多个核带来的额外并发远胜于快一些的时钟频率

- 内存配置：常见大于8G小于64G
内存资源是最容易被耗尽的，因为排序和聚合都是内存消耗严重，因此足够的堆空间用来应付是十分重要的。
Lucene的索引文件segements是储存在但文件中并且不可变，对于OS来说，如果能够通过mmap缓存在cache中，能够快速访问，因此，很有必要留一半空间给Lucene，另外一半留给ES（JVM heap）。
当小于64G：通用原则，一半一半
当大于64G:
- - 针对全文检索场景，给ES留8-32G，剩下留给操作系统，
- - 针对场景是聚合和排序(numerics, dates, peo_points,not_analyzed字段)分配给ES 4-32G，剩下留给操作系统，提供快速基于文档的聚类、排序性能。
- - 如果在上述的基础上，都是基于analyzed字符数据，需要更多的heap size，建议上更多ES实例，每个保持不超过50%的ES heap配置（不要超过32G，堆空间在32G以下时，JVM会使用对象指标压缩技巧节省空间），50%以上留给Lucene。

- 禁止swap
一旦允许内存和磁盘交换，会引发严重性能问题。

- GC设置
尽可能使用高版本的GC

- 磁盘
磁盘是服务器上最慢的子系统，意味着*大量写的集群很容易让磁盘饱和*，成为集群瓶颈
经济允许**尽可能使用SSD**，并且使用正确的调度程序（默认的调度程序是分配时间片到每个程序，并优化到磁盘众多队列的传递，但这是为旋转介质优化的，SSD直接访问意味着会更加高效（除了deadline (写入等待优化)和noop(简单FIFO)）
使用RAID0(禁用磁盘默认的备份功能)
避免使用NAS

### 2.2 索引优化
索引优化主要集中在针对插入的优化，本身索引速度还是很快的
- 批量提交(Bulk)
在大量数据提交时，使用bulk，每个请求不超过20MB
如果出现ESRejectExecutionException，说明性能达到瓶颈，要么提高服务集群的资源，要么减少数据收集速度，只收集Warn，Error的日志

- 增加Refresh间隔
为了提高索引性能，ES使用的是延迟写入，先写入内存，超过refresh_interval才会写入操作，将内存中的segment数据刷新到磁盘中，此时才能搜索出来数据。

在全量索引时，可以先关闭refresh，导入成功后再打开

- 修改index_buffer_size
index_buffer_size 用于设置索引缓存的大小，默认是10%的堆空间。
如果索引数据量很大，建议适当调大这个参数。

- 修改translog相关设置
可以修改sync_interval（操作频率）和flush_threshold_size（文件大小，满了才发）
如果索引数据量很大，建议适当调大这两个参数。

- 避免自定义_id

- 注意_all字段和_source字段使用
_all已废弃，用于全字段查找
_source选择是否返回原始文档，还是仅返回idx等信息，并且关闭后无法根据ID对文档进行update操作，只能通过全量修改的方式，因为完全覆盖了文档

- 合理配置使用index属性
analyzed和not_analyzed，根据业务需求来控制字段是否分词或者不分词。只有groupby需求的字段，就设置成not_analyzed，提高查询和聚类效率

- 减少副本数量
ES默认副本数为3，会提高集群可用性，增加搜索的并发数，但同时会影响写入效率。
当写入时，需要把更新的文档发送到副本节点上，等副本节点生效后再进行返回结束。虽然请求发送是同时的，但写入时候是单一实现的（不知道能不能通过写入一个再让他给别人写）。
对于日志，分布式追踪系统等，可以设置副本为1，减少过长等待。

























# 补充知识点
## 1. 为什么排序和聚合很耗内存？
### 在ES中，排序对搜索结果对某个字段排序(例如price desc)会触发以下操作：
- 读取大量文档的字段值（数万个）
- 构建一个排序队列（通常是优先队列），用于保持对Top-N的排序结果
- 如果字段是text类型或者doc_values没启用？就需要倒排索引或源数据加载
### 内存消耗在：
- 排序字段的加载和缓存
- 排序队列的构建(top hits heap)
- 数据结构(例如FieldComparator和PriorityQueue)

### 聚合，如terms,histogram,data_histogram等：
- 扫描 **匹配的所有文档**
- 对特定字段进行分桶(如term就是对字段值的分组)
- 为每个桶维护中间状态(计数，和，平均等)
### 内存消耗在：
- 每个桶的通缉对象(计数器，数值聚合等)
- 分桶结构(HashMap, TreeMap)
- 聚合器中间结构(internalAggregations)
- **尤其是terms aggregation，在高基数字段十分吃内存**

## 2. 什么是堆空间？和ES有什么关系？
堆空间(JAVA Heap): 是JVM为每个进程分配的内存区域，用于存放所有运行时的对象（例如ES缓存，索引结构，聚合器状态等）
因为JS是基于JAVA的，因此所有中间态都存放在堆中
如果堆空间不够:
- 会导致频繁的GC，影响搜索性能
- 聚合/排序中间数据溢出，导致OOM
- ES强制将部分数据写入磁盘(spill over) ->性能急剧下降

## 3. 什么是Lucene？和ES有什么关系？Lucene用到了哪些基于磁盘的数据结构？
Lucene是一个基于JAVA的全文搜索引擎库，它提供了索引、搜索和排名功能。
ES是基于Lucene的搜索服务器，它提供了分布式、可扩展的实时搜索功能。
ES的索引和搜索功能都是基于Lucene实现的。
Lucene用到了哪些基于磁盘的数据结构？
- 倒排索引
- - 字词 -> 文档ID列表（储存在.itm,.doc,.pos,.idx文件中）
- 文档向量(doc vectors)
- - 文档的数值表示(特征空间、向量空间)典型结构
- - 典型结构是倒排索引posting list和embedding list
- - 通常用于搜索排序、向量检索、相似度计算
- - 通常是稀疏/稠密结构(TF-IDF, embedding)
- 文档存储(doc values)
- - 每个字段 -> 所有文档的值 (user_id: 123456)
- - 储存在.dvd, .dvm中，支持mmap
- 位图索引 (Bitset)
- - 用于过滤吧、缓存结果、字段是否存在等布尔信息
同行不会完全加载入堆内存，而是通过mmap或随机ID从磁盘读取

## 4. 为什么“操作系统文件缓存”很重要？
ES 非常独特也非常聪明的设计：
 操作系统文件缓存（OS Page Cache）：
是 Linux 内核用来缓存最近访问的磁盘页的一块内存
ES/Lucene 把数据结构放在 mmap 映射文件中，而不是 Java 堆
一旦某部分被访问多次，操作系统自动把它缓存进内存
从 OS page cache 读数据远快于磁盘随机 IO，几乎接近内存速度

## 5. 什么是mmap?
全称是内存映射文件 (memory-mapped file)
将文件内容直接映射到进程的虚拟内存中
通常用户访问的文件的时候会通过read()系统调用，读到用户空间的buffer中
mmap的操作就是把文件整个或部分（按需加载，当访问到页才会加载）映射到内存空间中，通过读内存一样去读取磁盘中的数据。


## 6. 什么是swap?为什么es要禁用swap？
swap是linux的虚拟内存机制，当物理内存不够时，会把不常用的内存页移到磁盘(swap空间)中，腾出内存供其他进程使用
可以简单抽象成抽屉，不常用的会被收起来，当你使用的时候，就打开抽屉取（页调入），比直接拿要慢一些

ES要禁用swap:
- JVM内部的堆内存是**基于频繁的热点数据**，一旦数据被swap出去，任何GC的操作或对象分配都会变得很慢，导致ES查询延迟急剧提升，吞吐下降，甚至OOM崩溃
- 并且Lucene的mmap数据结构也会依赖，频繁swap反而会拖慢IO性能
- GC需要频繁访问整个堆对象图，如果在swap中，会导致GC缓慢，出现"ES卡住、Load升高、内存没有存满但进程无响应"

## 7. 什么是RAID？RAID0又是什么？
RAID（Redundant Array of Independent Disks），即独立磁盘冗余阵列，是把多个硬盘组合成一个逻辑磁盘来提高性能、容错或两者兼顾的技术。
 RAID 0：条带化（Striping）
📌 特点：
把数据平均分块写入多个磁盘，每个磁盘只负责其中一部分，**所有磁盘**同时参与读写，大幅提高性能。没有冗余、没有容错机制，只要有一个硬盘坏了，全部数据丢失

| RAID 类型 | 核心机制            | 冗余性 | 可靠性    | 性能      | 容量可用率   | 典型用途        |
| ------- | --------------- | --- | ------ | ------- | ------- | ----------- |
| RAID 0  | 条带（分块）          | ❌ 无 | ❌ 最差   | ✅ 最快    | 100%    | 高速缓存、临时数据   |
| RAID 1  | 镜像（复制）          | ✅ 有 | ✅ 高    | 读快、写慢一点 | 50%     | 数据库、重要文件    |
| RAID 5  | 条带 + 奇偶校验       | ✅ 有 | ✅ 中高   | 读快、写较慢  | (N-1)/N | 大型存储，性价比优   |
| RAID 6  | 双重校验            | ✅ 有 | ✅✅ 更高  | 写慢      | (N-2)/N | 企业存储、容错更强   |
| RAID 10 | RAID 1 + RAID 0 | ✅ 有 | ✅✅✅ 极高 | ✅ 非常快   | 50%     | 高可用 + 高性能场景 |

## 8. ES的_update操作：
- 找到 _id 对应的文档
- 读取 _source 原始内容
- 把要修改的字段“合并”进去
- 重建一个新文档（Lucene 只能追加写）
- 再写入索引中

