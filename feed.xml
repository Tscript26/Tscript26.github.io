<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Ethan's Blog</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle> <updated>2026-02-15T10:07:41+08:00</updated> <author> <name>Ethan</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh" href="/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2026 Ethan </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>如何正确实现JAVA单例的热加载</title><link href="/posts/Bean%E7%83%AD%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0/" rel="alternate" type="text/html" title="如何正确实现JAVA单例的热加载" /><published>2026-02-12T14:30:00+08:00</published> <updated>2026-02-12T14:30:00+08:00</updated> <id>/posts/Bean%E7%83%AD%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0/</id> <content type="text/html" src="/posts/Bean%E7%83%AD%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0/" /> <author> <name>Ethan</name> </author> <category term="Java" /> <summary>昨日说到，由于apollo配置错误导致了redis加载日常，并且由于单例导致无法通过apollo实现热重载，那么我应该如何正确的热重载逻辑呢？ 基于这个思考，我开始考虑之前gemini提到的Spring Cloud中的refreshScope。 我参考网上的写法，实现了一下@refreshScope并添加了apollo的监视器用于调用refreshScope，但是运行的时候，骤然发现了大量的加载异常，其中最刺眼的就是Servlet异常。 我明明用的是Webflux，怎么会有Servlet相关的异常？想想我自己的更改：为了实现Bean的热重载，给pom增加了spring-cloud，给方法增加了refreshScope....，会不会是Spring-Cloud带来的？ 调查Spring Cloud 针对于Spring Cloud 的背后故事进行了调查，发现大量关于servlet...</summary> </entry> <entry><title>生产救火：当 Apollo 遇上单例 Bean，我如何用 Arthas 逆天改命？</title><link href="/posts/java%E7%83%AD%E9%87%8D%E8%BD%BD/" rel="alternate" type="text/html" title="生产救火：当 Apollo 遇上单例 Bean，我如何用 Arthas 逆天改命？" /><published>2026-02-12T14:30:00+08:00</published> <updated>2026-02-12T17:31:52+08:00</updated> <id>/posts/java%E7%83%AD%E9%87%8D%E8%BD%BD/</id> <content type="text/html" src="/posts/java%E7%83%AD%E9%87%8D%E8%BD%BD/" /> <author> <name>Ethan</name> </author> <category term="Java" /> <summary>危机现场：失联的 Redis 想象一下，你刚刚部署了一个基于 Spring WebFlux 的微服务，信心满满地盯着监控。突然，告警全线飘红：Connection Refused。 一番排查后，你发现了一个尴尬的真相：容器内的 DNS 解析出了问题。Apollo 配置中心无法连接，导致服务启动时回退到了错误的默认配置。Redis 客户端正对着一个不存在的地址疯狂尝试。 此时你面临两个选择： 重启容器：最简单，但可能丢失现场，且由于是高敏感业务，频繁重启可能触发更严密的风控审核。 热修复：在不重启的前提下，把网络通掉，并让内存里的对象“醒悟”过来。 我选择了后者。 第一阶段：通网与初步尝试 1. 建立网络互信 首先要解决网络层的“失联”。在 Linux 容器中，/etc/hosts 是我们最后的尊严。 # 进入容器，手动将配置中心指向正确 IP echo ...</summary> </entry> <entry><title>红黑树</title><link href="/posts/red-black-tree/" rel="alternate" type="text/html" title="红黑树" /><published>2026-01-25T02:00:00+08:00</published> <updated>2026-01-25T02:00:00+08:00</updated> <id>/posts/red-black-tree/</id> <content type="text/html" src="/posts/red-black-tree/" /> <author> <name>Ethan</name> </author> <category term="Java" /> <category term="Tutorial" /> <summary>红黑树是对‘查找效率’和‘维护成本’的一种优雅妥协。它不追求 AVL 那样的极致物理平衡，而是通过‘黑高相等’和‘红不连续’确保了逻辑上的近似平衡，从而在频繁变动的数据场景下展现出更优异的综合性能。 红黑树的规则 红黑树有五条最根本的规则 | 规则编号 | 规则名称 | 规则具体内容 | 老师的深度大白话 | | —- | —— | ——————————– | ————————- | | 规则 1 | 节点颜色 | 每个节点要么是红色，要么是黑色。 | 只有两种身份，非红即黑。 | | 规则 2 | 根节点特性 | 根节点 (Root) 必须是黑色。 | 树的“头”一定要稳，必须是黑色的。 ...</summary> </entry> <entry><title>Java 响应式编程核心：Mono 与 Flux 指南</title><link href="/posts/java-mono-and-flux/" rel="alternate" type="text/html" title="Java 响应式编程核心：Mono 与 Flux 指南" /><published>2026-01-25T02:00:00+08:00</published> <updated>2026-01-25T02:00:00+08:00</updated> <id>/posts/java-mono-and-flux/</id> <content type="text/html" src="/posts/java-mono-and-flux/" /> <author> <name>Ethan</name> </author> <category term="Java" /> <category term="Tutorial" /> <summary>1. 核心概念：什么是响应式流？ 在响应式编程中，数据不再是被“拿”过来的，而是像水一样流过来的。 Flux (多元素流)：代表 0 到 N 个元素的异步序列。你可以把它看作一条传送带，上面会陆续送来零件。 Mono (单元素流)：代表 0 到 1 个元素的异步序列。你可以把它看作一个快递盒，打开后要么有一个零件，要么是空的。 核心定律：不订阅，无事发生 Nothing happens until you subscribe. 你写的 map, filter, flatMap 只是在“铺设水管”，如果你不打开水龙头（订阅），一滴水（数据）都不会流过。 2. 为什么 return 就能执行？ 在 Spring WebFlux（如 Controller 层）中，你通常只写 return 而不写 .subscribe()，但代码依然运行了。这是因为： 框...</summary> </entry> <entry><title>华为小艺接入分析</title><link href="/posts/huawei-agent/" rel="alternate" type="text/html" title="华为小艺接入分析" /><published>2025-12-03T17:00:00+08:00</published> <updated>2025-12-03T17:00:00+08:00</updated> <id>/posts/huawei-agent/</id> <content type="text/html" src="/posts/huawei-agent/" /> <author> <name>一三</name> </author> <category term="Work" /> <summary>小艺 A2A 模式开发规范（速览） 小艺是2025年11月份开放的A2A能力，允许用户通过小艺访问第三方开发的agent服务。（目前应该还是需要和商务联系，这个没有广泛开放） 华为官方文档 需要在创建好账号之后，在小艺开发平台通过A2A模式创建智能体，配置智能体的名称，智能体描述（用于做意图分发），API URL，会话维持的方式，以及认证方式等 面向本地 Agent Server 适配华为小艺 A2A 协议的开发说明，便于后端快速对接和自测。 1. 接口形态 单一入口：POST /agent/message 协议：JSON-RPC 2.0 必要 Header： Content-Type: application/json agent-session-id（除 initialize 外必需） Authorization（...</summary> </entry> </feed>
