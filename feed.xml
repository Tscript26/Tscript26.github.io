<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Chirpy</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle> <updated>2026-02-12T17:47:41+08:00</updated> <author> <name>Ethan</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh" href="/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2026 Ethan </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>生产救火：当 Apollo 遇上单例 Bean，我如何用 Arthas 逆天改命？</title><link href="/posts/java%E7%83%AD%E9%87%8D%E8%BD%BD/" rel="alternate" type="text/html" title="生产救火：当 Apollo 遇上单例 Bean，我如何用 Arthas 逆天改命？" /><published>2026-02-12T14:30:00+08:00</published> <updated>2026-02-12T17:31:52+08:00</updated> <id>/posts/java%E7%83%AD%E9%87%8D%E8%BD%BD/</id> <content type="text/html" src="/posts/java%E7%83%AD%E9%87%8D%E8%BD%BD/" /> <author> <name>Ethan</name> </author> <category term="Java" /> <summary>危机现场：失联的 Redis 想象一下，你刚刚部署了一个基于 Spring WebFlux 的微服务，信心满满地盯着监控。突然，告警全线飘红：Connection Refused。 一番排查后，你发现了一个尴尬的真相：容器内的 DNS 解析出了问题。Apollo 配置中心无法连接，导致服务启动时回退到了错误的默认配置。Redis 客户端正对着一个不存在的地址疯狂尝试。 此时你面临两个选择： 重启容器：最简单，但可能丢失现场，且由于是高敏感业务，频繁重启可能触发更严密的风控审核。 热修复：在不重启的前提下，把网络通掉，并让内存里的对象“醒悟”过来。 我选择了后者。 第一阶段：通网与初步尝试 1. 建立网络互信 首先要解决网络层的“失联”。在 Linux 容器中，/etc/hosts 是我们最后的尊严。 # 进入容器，手动将配置中心指向正确 IP echo ...</summary> </entry> <entry><title>红黑树</title><link href="/posts/red-black-tree/" rel="alternate" type="text/html" title="红黑树" /><published>2026-01-25T02:00:00+08:00</published> <updated>2026-01-25T02:00:00+08:00</updated> <id>/posts/red-black-tree/</id> <content type="text/html" src="/posts/red-black-tree/" /> <author> <name>Ethan</name> </author> <category term="Java" /> <category term="Tutorial" /> <summary>红黑树是对‘查找效率’和‘维护成本’的一种优雅妥协。它不追求 AVL 那样的极致物理平衡，而是通过‘黑高相等’和‘红不连续’确保了逻辑上的近似平衡，从而在频繁变动的数据场景下展现出更优异的综合性能。 红黑树的规则 红黑树有五条最根本的规则 | 规则编号 | 规则名称 | 规则具体内容 | 老师的深度大白话 | | —- | —— | ——————————– | ————————- | | 规则 1 | 节点颜色 | 每个节点要么是红色，要么是黑色。 | 只有两种身份，非红即黑。 | | 规则 2 | 根节点特性 | 根节点 (Root) 必须是黑色。 | 树的“头”一定要稳，必须是黑色的。 ...</summary> </entry> <entry><title>Java 响应式编程核心：Mono 与 Flux 指南</title><link href="/posts/java-mono-and-flux/" rel="alternate" type="text/html" title="Java 响应式编程核心：Mono 与 Flux 指南" /><published>2026-01-25T02:00:00+08:00</published> <updated>2026-01-25T02:00:00+08:00</updated> <id>/posts/java-mono-and-flux/</id> <content type="text/html" src="/posts/java-mono-and-flux/" /> <author> <name>Ethan</name> </author> <category term="Java" /> <category term="Tutorial" /> <summary>1. 核心概念：什么是响应式流？ 在响应式编程中，数据不再是被“拿”过来的，而是像水一样流过来的。 Flux (多元素流)：代表 0 到 N 个元素的异步序列。你可以把它看作一条传送带，上面会陆续送来零件。 Mono (单元素流)：代表 0 到 1 个元素的异步序列。你可以把它看作一个快递盒，打开后要么有一个零件，要么是空的。 核心定律：不订阅，无事发生 Nothing happens until you subscribe. 你写的 map, filter, flatMap 只是在“铺设水管”，如果你不打开水龙头（订阅），一滴水（数据）都不会流过。 2. 为什么 return 就能执行？ 在 Spring WebFlux（如 Controller 层）中，你通常只写 return 而不写 .subscribe()，但代码依然运行了。这是因为： 框...</summary> </entry> <entry><title>华为小艺接入分析</title><link href="/posts/huawei-agent/" rel="alternate" type="text/html" title="华为小艺接入分析" /><published>2025-12-03T17:00:00+08:00</published> <updated>2025-12-03T17:00:00+08:00</updated> <id>/posts/huawei-agent/</id> <content type="text/html" src="/posts/huawei-agent/" /> <author> <name>一三</name> </author> <category term="Work" /> <summary>小艺 A2A 模式开发规范（速览） 小艺是2025年11月份开放的A2A能力，允许用户通过小艺访问第三方开发的agent服务。（目前应该还是需要和商务联系，这个没有广泛开放） 华为官方文档 需要在创建好账号之后，在小艺开发平台通过A2A模式创建智能体，配置智能体的名称，智能体描述（用于做意图分发），API URL，会话维持的方式，以及认证方式等 面向本地 Agent Server 适配华为小艺 A2A 协议的开发说明，便于后端快速对接和自测。 1. 接口形态 单一入口：POST /agent/message 协议：JSON-RPC 2.0 必要 Header： Content-Type: application/json agent-session-id（除 initialize 外必需） Authorization（...</summary> </entry> <entry><title>代码执行沙盒（</title><link href="/posts/my-sandbox/" rel="alternate" type="text/html" title="代码执行沙盒（" /><published>2025-12-03T08:00:00+08:00</published> <updated>2025-12-03T08:00:00+08:00</updated> <id>/posts/my-sandbox/</id> <content type="text/html" src="/posts/my-sandbox/" /> <author> <name>一三</name> </author> <category term="Learn" /> <category term="Work" /> <summary>为什么要重新写一个沙盒？ 原有能力不足，缺少定制化 venv，缺少参数验证，缺少执行日志的持久化。原有 Dify 代码节点虽然写了参数校验，但实际上不写也能跑，风险很高。 额外实现了哪些功能？ python 虚拟环境和依赖实现动态管理，可以通过配置文件、接口、kafka三种方式进行虚拟环境管理 更好的参数校验功能，支持输入和输出参数校验，如果有输出参数校验，可以输出格式化的json数据 实施细节 代码路径：ubuntu/home/dify-sandbox，基于 dify-sandbox 二次开发。 内部结构：核心服务（沙盒 API）、执行引擎（拉起隔离容器 / venv）、日志模块（持久化运行记录）。 运行模式：支持配置文件模式、REST API 模式、Kafka 事件驱动模式三种入口，默认启用安全参数校验。 快速上手（模板） # 1) 切换到项目 ...</summary> </entry> </feed>
