以下是为你定制的一批操作系统面试题，涵盖了**进程管理、内存管理、文件系统、IO、多线程/多进程通信等常考方向**，并配有简要解释：

---

### 🧠 一、进程与线程

1. **进程和线程有什么区别？各自的使用场景是什么？**

   > 进程有独立的地址空间，线程共享进程空间；线程开销更小，适合密集计算或IO并发。

2. **线程之间如何通信？与进程间通信有何不同？**

   > 线程共享内存，通信可以直接通过变量；进程需要管道、消息队列、共享内存等IPC机制。

3. **什么是上下文切换（Context Switch）？什么时候发生？**

   > 当CPU从一个进程/线程切换到另一个时发生。会有缓存、寄存器、内存映射切换，代价较高。

4. **fork() 与 exec() 的区别？**

   > `fork()`复制当前进程，`exec()`则替换当前进程映像。

5. **父子进程之间如何共享文件描述符？**

---

### 📦 二、内存管理与虚拟内存

6. **什么是分页（Paging）？与分段（Segmentation）有何不同？**

   > 分页是等长分块、便于管理；分段是逻辑划分，便于按需访问。

7. **什么是虚拟内存？为什么要使用它？**

   > 虚拟内存让程序可以“假装”有连续空间，通过页表映射实际物理地址，实现内存隔离和高效管理。

8. **页面置换算法有哪些？请解释 LRU 和 FIFO 的异同。**
LRU,LFU,FIFO,OPT,Clock
OPT: 理想算法，淘汰未来最不可能


9. **什么是 Copy-on-Write？fork 出的子进程什么时候会真正复制内存？**

10. **mmap 和 malloc 的区别？什么场景用 mmap？**

---

### 📂 三、文件系统

11. **什么是 inode？它包含哪些信息？**

> inode 是文件元数据结构，包含文件大小、权限、时间戳、块指针等，不包含文件名。

12. **硬链接（Hard Link）与软链接（Symbolic Link）区别？**

13. **文件打开过程的系统调用顺序？（open → read/write → close）**

> 可以提及系统调用涉及的 file descriptor 表、inode 表等。

---

### 🔌 四、IO 与中断机制

14. **阻塞 IO、非阻塞 IO、IO 多路复用（select/poll/epoll）区别？**

| 模型          | 描述                                          | 特点                           |
| ----------- | ------------------------------------------- | ---------------------------- |
| **阻塞 IO**   | `read()` 等系统调用会阻塞直到数据准备好（等待 + 拷贝）           | 简单易用，但性能差，线程会被挂起，占用资源        |
| **非阻塞 IO**  | 系统调用立即返回，若无数据则返回 `EAGAIN` 错误                | 需轮询，CPU 开销大                  |
| **IO 多路复用** | 单线程同时监听多个 fd（如通过 `select`, `poll`, `epoll`） | 高并发场景常用，节省线程数，需明确通知哪些 fd 就绪  |
| **异步 IO**   | 提交 IO 后立即返回，由内核完成数据拷贝，并通过事件通知               | 理论最优，但实际支持有限（Linux 的 aio 较弱） |

| 模型          | 描述                                          | 特点                           |
| ----------- | ------------------------------------------- | ---------------------------- |
| **select**   | 轮询所有 fd，阻塞直到有就绪事件                | 支持 fd 数量少，性能低                  |
| **poll**     | 轮询所有 fd，阻塞直到有就绪事件                | 支持 fd 数量多，性能低                  |
| **epoll**    | 基于事件回调机制，无需轮询，仅监听就绪事件        | 支持 fd 数量多，性能高                  |


15. **epoll 的工作原理及与 select 区别？为什么性能更好？**

| 对比点    | `select/poll`                              | `epoll`                             |
| ------ | ------------------------------------------ | ----------------------------------- |
| fd 管理  | 用户态传入所有 fd，每次调用都拷贝一份                       | 注册后由内核维护，无需每次传入                     |
| 事件通知机制 | 线性扫描（O(n)），轮询检查所有 fd                       | 回调事件机制 + 内核事件就绪队列（O(1)），只通知活跃 fd    |
| 上限限制   | `select` 最多支持 1024 个 fd（宏 `FD_SETSIZE` 限制） | `epoll` 理论无限制，效率更高                  |
| 模式     | 无状态                                        | 支持水平触发（LT）和边缘触发（ET）两种模式，ET 更高效但更难控制 |
> epoll 使用事件回调机制，不需遍历所有文件描述符。

16. **什么是 DMA？它如何提高 IO 效率？**
> DMA 直接内存访问，无需 CPU 参与，外设直接将数据写入内存，避免了 CPU 拷贝，提高效率。

> 外设 → DMA 控制器 ⟶ 内存（无需 CPU 参与数据搬运）

> 外设 → IO 控制器 → CPU 拷贝 → 内存

---

### ⏱ 五、调度与同步

17. **操作系统常用的调度算法有哪些？请列举两种并解释优劣。**
调度算法：
> 如：FCFS、SJF、轮转RR、优先级、MLFQ 等。

18. **什么是信号量（Semaphore）？互斥锁（Mutex）与它的区别？**

19. **死锁的必要条件？如何避免死锁？**

---

## 💬 六、经典问题

### 20. **孤儿进程与僵尸进程的区别？如何处理？**

| 类型             | 定义                                | 表现              | 是否占资源    | 如何处理                          |
| -------------- | --------------------------------- | --------------- | -------- | ----------------------------- |
| 🧟‍♂️ **僵尸进程** | 子进程执行完毕，**父进程未调用 `wait()` 回收其状态** | 仍留有进程表项（pid）    | ✅ 占用 PCB | 父进程调用 `wait()` 或由 init 进程接管回收 |
| 👻 **孤儿进程**    | **父进程先退出，子进程仍在运行**                | 被 init（PID=1）接管 | ❌ 不占资源   | 自动由 init 回收子进程资源              |
> 僵尸进程多了会耗尽 PID 表 → 系统无法创建新进程

> 可用 ps -el | grep Z 查找僵尸进程
21. **系统调用与库函数有什么区别？请举例说明。**

| 比较项    | 系统调用（System Call）                       | 库函数（Library Function）              |
| ------ | --------------------------------------- | ---------------------------------- |
| 所在位置   | 操作系统内核提供                                | 用户空间提供的函数集合（如 libc）                |
| 是否切换模式 | ✅ 会从用户态 → 内核态                           | ❌ 不会，除非调用内部的系统调用                   |
| 举例     | `read()`, `write()`, `fork()`, `open()` | `printf()`, `scanf()`, `strcpy()`  |
| 调用开销   | 高，需要上下文切换和陷入内核                          | 低，仅用户空间执行                          |
| 是否依赖内核 | ✅ 直接操作硬件资源                              | ❌ 多为便捷封装（如 `fopen()` 封装了 `open()`） |

```
// 系统调用
int fd = open("file.txt", O_RDONLY);  // 进入内核态

// 库函数
FILE* f = fopen("file.txt", "r");     // 用户态调用，底层可能调用 open()
```

22. **操作系统的内核态（Kernel Mode）和用户态（User Mode）有何不同？**

| 对比项  | 用户态（User Mode） | 内核态（Kernel Mode）      |
| ---- | -------------- | --------------------- |
| 权限   | 受限，只能访问自己的内存空间 | 全权限，能访问硬件、内存管理等       |
| 运行主体 | 普通应用程序         | 操作系统核心组件（调度器、驱动、文件系统） |
| 内存访问 | 无法访问内核空间       | 可访问任意内存地址             |
| 出错后果 | 程序崩溃，不影响系统     | 若崩溃可能导致系统崩溃           |
| 切换方式 | 系统调用 / 中断      | 返回用户态需通过上下文切换         |

23. **介绍一次系统从开机到进入登录界面的完整流程。**

- 上电自检（POST）
检查 CPU、内存、显卡等是否正常

- 加载 BIOS/UEFI
初始化硬件、加载启动设备（如硬盘、U盘）

- 加载引导程序（Bootloader，如 GRUB）
从 MBR/GPT 加载 Bootloader，选择启动内核

- 加载操作系统内核（Kernel）
解压并加载 Linux 或 Windows 内核 → 启动 PID 1（如 systemd）

- 内核初始化阶段
设置中断表、初始化内存、挂载根文件系统

- 启动第一个用户空间程序（init/systemd）
启动各类服务、网络、日志等

- 启动登录服务（getty/login/gdm）
控制台登录或图形界面登录（GUI）

- 进入用户桌面环境
启动 gnome, kde, explorer.exe 等 GUI 程序
---


7. 敏捷模式和瀑布模式的区别是什么？  
敏捷模式和瀑布模式的核心区别体现在流程灵活性与适应场景上。**瀑布模式是线性阶段式开发**，按需求、设计、开发、测试、部署的顺序依次推进，前一阶段完成后才进入下一阶段，需求需前期明确，后期变更成本高，适合需求稳定、文档要求严格的项目。**敏捷模式则是迭代式开发**，将项目拆分为短周期 Sprint，每个周期包含完整开发环节，强调快速响应需求变化，通过每日站会等方式保持紧密协作，客户可全程参与并反馈，适合需求动态变化、需快速交付的场景。前者依赖前期规划，后者侧重迭代优化，选择需结合项目特性与团队协作模式。